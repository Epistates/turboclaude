//! Example: Message Filtering
//!
//! Demonstrates the ergonomic message filtering methods for processing
//! specific message types from the agent session stream.
//!
//! This example shows the API usage patterns. In a real application, you would
//! need a running Claude CLI process and proper session initialization.
//!
//! Run with:
//! ```
//! cargo run --package turboclaudeagent --example message_filtering
//! ```

use futures::StreamExt;
use turboclaudeagent::SessionConfig;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("Message Filtering Example\n");
    println!("This example demonstrates the filtering API patterns.");
    println!("(Note: Requires a running Claude CLI process to execute)\n");

    // Example 1: Filter for assistant messages only
    println!("Example 1: Receiving assistant messages only");
    println!("==============================================");
    println!("Code pattern:");
    println!(r#"
    let session = AgentSession::new(config).await?;
    session.query_str("What is 2+2?").await?;

    let mut stream = Box::pin(session.receive_assistant_messages().await);

    println!("Waiting for assistant responses...");
    let mut count = 0;
    while let Some(result) = assistant_stream.next().await {
        match result {
            Ok(msg) => {
                println!("Assistant: {}", msg.model);
                for content in msg.content {
                    if let Some(text) = content.as_text() {
                        println!("  Content: {}", text);
                    }
                }
                count += 1;
                if count >= 1 {
                    break; // Only process first message for demo
                }
            }
            Err(e) => {
                eprintln!("Error: {}", e);
                break;
            }
        }
    }

    // Example 2: Filter for stream events only
    println!("\nExample 2: Receiving stream events only");
    println!("Sending query...");

    let _response = session.query_str("Count to 5").await?;

    let mut stream_events = Box::pin(session.receive_stream_events().await);

    println!("Waiting for stream events...");
    let mut count = 0;
    while let Some(result) = stream_events.next().await {
        match result {
            Ok(event) => {
                println!("Stream event: uuid={}", event.uuid);
                count += 1;
                if count >= 3 {
                    break; // Only process first 3 events for demo
                }
            }
            Err(e) => {
                eprintln!("Error: {}", e);
                break;
            }
        }
    }

    // Example 3: Filter for result messages (query completion)
    println!("\nExample 3: Receiving result messages only");
    println!("Sending query...");

    let _response = session.query_str("Tell me a joke").await?;

    let mut results = Box::pin(session.receive_results().await);

    println!("Waiting for result...");
    if let Some(result) = results.next().await {
        match result {
            Ok(msg) => {
                println!("Query complete!");
                println!("  Duration: {}ms", msg.duration_ms);
                println!("  Turns: {}", msg.num_turns);
                println!("  Error: {}", msg.is_error);
                if let Some(cost) = msg.total_cost_usd {
                    println!("  Cost: ${:.4}", cost);
                }
            }
            Err(e) => {
                eprintln!("Error: {}", e);
            }
        }
    }

    // Example 4: Multiple filters on the same stream (different types)
    println!("\nExample 4: Using multiple filters");
    println!("Sending query...");

    let _response = session.query_str("Explain Rust ownership").await?;

    // Spawn tasks to process different message types concurrently
    let session_clone = session.clone();
    let assistant_task = tokio::spawn(async move {
        let mut stream = Box::pin(session_clone.receive_assistant_messages().await);
        let mut count = 0;
        while let Some(result) = stream.next().await {
            if let Ok(msg) = result {
                println!("  [Assistant] Received response with {} content blocks", msg.content.len());
                count += 1;
                if count >= 1 {
                    break;
                }
            }
        }
    });

    let session_clone2 = session.clone();
    let stream_task = tokio::spawn(async move {
        let mut stream = Box::pin(session_clone2.receive_stream_events().await);
        let mut count = 0;
        while let Some(result) = stream.next().await {
            if let Ok(event) = result {
                println!("  [Stream] Event: {}", event.uuid);
                count += 1;
                if count >= 3 {
                    break;
                }
            }
        }
    });

    // Wait for both tasks
    let _ = tokio::join!(assistant_task, stream_task);

    println!("\nExample complete!");

    // Clean up
    session.close().await?;

    Ok(())
}
