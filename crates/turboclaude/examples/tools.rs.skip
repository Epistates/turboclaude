//! Example demonstrating tool use with the Turboclaude SDK

use turboclaude::{
    types::{Message, MessageRequest},
    Client, Tool,
};
use serde_json::json;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a client
    let client = Client::builder()
        .api_key("sk-ant-api-key") // Replace with your actual API key
        .build()?;

    // Define a tool (function) that Claude can use
    let calculator_tool = Tool::new(
        "calculator",
        "Performs basic arithmetic operations",
        json!({
            "type": "object",
            "properties": {
                "operation": {
                    "type": "string",
                    "enum": ["add", "subtract", "multiply", "divide"],
                    "description": "The arithmetic operation to perform"
                },
                "a": {
                    "type": "number",
                    "description": "First number"
                },
                "b": {
                    "type": "number",
                    "description": "Second number"
                }
            },
            "required": ["operation", "a", "b"]
        }),
    );

    let get_weather_tool = Tool::new(
        "get_weather",
        "Gets the current weather for a location",
        json!({
            "type": "object",
            "properties": {
                "location": {
                    "type": "string",
                    "description": "City name, e.g., 'San Francisco, CA'"
                }
            },
            "required": ["location"]
        }),
    );

    // Create a message request with tools
    let request = MessageRequest::builder()
        .model(Models::CLAUDE_3_5_SONNET)
        .max_tokens(1024u32)
        .tools(vec![calculator_tool, get_weather_tool])
        .tool_choice(ToolChoice::Auto) // Let Claude decide if/which tools to use
        .messages(vec![Message::user(
            "What is 42 multiplied by 17? Also, what's the weather like in Paris?",
        )])
        .build()?;

    println!("Sending request with tools to Claude...\n");

    // Send the request
    let message = client.messages().create(request).await?;

    println!("Claude's response:");

    // Process the response content blocks
    for (i, block) in message.content.iter().enumerate() {
        match block {
            ContentBlock::Text { text } => {
                println!("  [Text #{}]: {}", i + 1, text);
            }
            ContentBlock::ToolUse { id, name, input } => {
                println!("  [Tool Use #{}]:", i + 1);
                println!("    ID: {}", id);
                println!("    Tool: {}", name);
                println!("    Input: {}", serde_json::to_string_pretty(input)?);

                // In a real application, you would:
                // 1. Execute the tool with the given input
                // 2. Get the result
                // 3. Send it back to Claude in a follow-up message
            }
            _ => {}
        }
    }

    // Example of continuing the conversation with tool results
    println!("\n\n--- Continuing conversation with tool results ---\n");

    // Simulate tool execution (in a real app, you'd actually execute the tools)
    let tool_results = vec![
        ContentBlockParam::ToolResult {
            tool_use_id: "tool_use_123".to_string(), // Use the actual ID from the response
            content: "714".to_string(),              // Result of 42 * 17
            is_error: None,
        },
        ContentBlockParam::ToolResult {
            tool_use_id: "tool_use_124".to_string(),
            content: json!({
                "temperature": "18Â°C",
                "condition": "Partly cloudy",
                "humidity": "65%"
            })
            .to_string(),
            is_error: None,
        },
    ];

    // Note: In the actual implementation, you would build a proper follow-up message
    // with the conversation history and tool results. This is just a demonstration
    // of the types involved.

    println!("Tool results prepared:");
    for result in &tool_results {
        if let ContentBlockParam::ToolResult {
            tool_use_id,
            content,
            is_error,
        } = result
        {
            println!("  Tool Use ID: {}", tool_use_id);
            println!("  Result: {}", content);
            println!("  Is Error: {:?}", is_error);
        }
    }

    println!("\nUsage:");
    println!("  Input tokens: {}", message.usage.input_tokens);
    println!("  Output tokens: {}", message.usage.output_tokens);

    Ok(())
}
